#!@PERL@
# -*- mode: perl; coding: utf-8; -*-

# Comainu Executable Script for Unix-Compatible Platforms.

use strict;

our $Bin;
my $VERSION = "@APP_VERSION@";

BEGIN {
    # Must not use FindBin here. It should be reserved the real script.
    use File::Basename;
    use File::Spec;
    $Bin = File::Spec->rel2abs(File::Basename::dirname($0));
    push(@INC, "$Bin/../lib");
}

use utf8;
use Config;
use Getopt::Long;

use Comainu;

my $DEFAULT_VALUES = {
    "debug"                 => "0",
    "perl"                  => "@PERL@",
    "java"                  => "@JAVA@",
    "comainu-home"          => "@COMAINU_HOME@",
    "yamcha-dir"            => "@YAMCHA_DIR@",
    "chasen-dir"            => "@CHASEN_DIR@",
    "mecab-dir"             => "@MECAB_DIR@",
    "unidic-dir"            => "@UNIDIC_DIR@",
    "unidic2-dir"           => "@UNIDIC2_DIR@",
    "unidic-db"             => "@UNIDIC_DB@",
    "svm-tool-dir"          => "@SVM_TOOL_DIR@",
    "crf-dir"               => "@CRF_DIR@",
    "mstparser-dir"         => "@MSTPARSER_DIR@",
    "model-name"            => "@MODEL_NAME@",
    "comainu-svm-bip-model" => "train/BI_process_model",
    "comainu-output"        => "out",
    "comainu-temp"          => "tmp/temp",
    "boundary"              => "sentence",
    "luwmrph"               => "with",
    "suwmodel"              => "mecab",
    "luwmodel"              => "CRF",
    # "luwmrphmodel"          => "SVM",
    # "muwmodel"              => "MST",
    # "bnstmodel"             => "SVM",
};

my $OPT_NAME_LIST = [
    "perl",
    "java",
    "comainu-home",
    "yamcha-dir",
    "chasen-dir",
    "mecab-dir",
    "unidic-dir",
    "unidic2-dir",
    "unidic-db",
    "svm-tool-dir",
    "crf-dir",
    "mstparser-dir",
    "comainu-svm-bip-model",
    "comainu-output",
    "comainu-temp",
];

sub comainu_usage {
    my ($curr) = @_;
    printf("Usage : %s [options] <COMAINU-METHOD>  [<arg> ...]\n", $0);
    printf("  This script is front end of COMAINU.\n");
    printf("\n");
    printf("option:\n");
    printf("    --help                           show this message and exit\n");
    printf("    --debug          LEVEL           specify the debug level\n");
    printf("                                       (curr: '%s')\n", $curr->{"debug"});
    printf("    --version                        show version string\n");
    printf("    --help-method                    show the help of COMAINU-METHOD\n");
    printf("    --list-method                    show the list of COMAINU-METHOD\n");
    printf("    --force                          ignore cheking path of sub tools\n");
    printf("    --boundary       BOUNDARY        specify the type of boundary\n");
    printf("                                       BOUNDARY:=sentence|word\n");
    printf("                                       (curr: '%s')\n", $curr->{"boundary"});
    printf("    --luwmrph        LUWMRPH         whether to output morphology of long-unit-word\n");
    printf("                                       LUWMRPH:=with|without\n");
    printf("                                       (curr: '%s')\n", $curr->{"luwmrph"});
    printf("    --suwmodel       SUWMODEL        specify the type of the short-unit-word model\n");
    printf("                                       SUWMODEL:=mecab|chasen\n");
    printf("                                       (curr: '%s')\n", $curr->{"suwmodel"});
    printf("    --luwmodel       LUWMODEL        specify the type of the model for boundary of long-unit-word\n");
    printf("                                       LUWMODEL:=SVM|CRF\n");
    printf("                                       (curr: '%s')\n", $curr->{"luwmodel"});
    # printf("    --luwmrphmodel   LUWMRPHMODEL    specify the type of the long-unit-word model\n");
    # printf("                                       LUWMRPHMODEL:=SVM\n");
    # printf("                                       (curr: '%s')\n", $curr->{"luwmrphmodel"});
    # printf("    --muwmodel       MUWMODEL        specify the type of the middle-unit-word model\n");
    # printf("                                       MUWMODEL:=MST\n");
    # printf("                                       (curr: '%s')\n", $curr->{"muwmodel"});
    # printf("    --bnstmodel      BNSTMODEL       specify the type of the bnst model\n");
    # printf("                                       BNSTMODEL:=SVM\n");
    # printf("                                       (curr: '%s')\n", $curr->{"bnstmodel"});

    foreach my $var_name (@$OPT_NAME_LIST) {
        my $var_name_env = uc($var_name);
        $var_name_env =~ s/\-/_/gs;
        my $pad1 = " "x(32 - (length($var_name) + 6));
        my $pad2 = " "x(24 - length($var_name_env));
        printf("    --%s%s%s%sspecify %s\n",
               $var_name, $pad1, $var_name_env, $pad2, $var_name_env);
    }
    printf("\n");
    printf("Preset Environments :\n");
    foreach my $var_name (@$OPT_NAME_LIST) {
        my $var_name_env = uc($var_name);
        $var_name_env =~ s/\-/_/gs;
        printf("  %s=%s\n", $var_name_env, $ENV{$var_name_env});
    }
    print "\n";
}

sub comainu_version {
    my ($curr) = @_;
    printf("Comainu %s (perl:%s, osname:%s)\n",
           $VERSION, $Config{"version"}, $Config{"osname"});
}

sub comainu {
    # ---------- Common Path Environments ----------
    my $env_values = {};
    foreach my $var_name ( @$OPT_NAME_LIST ) {
        my $var_name_env = uc $var_name;
        $var_name_env =~ s/\-/_/gs;
        unless ( $ENV{$var_name_env} ) {
            $ENV{$var_name_env} = $DEFAULT_VALUES->{$var_name};
        } else {
            $env_values->{$var_name} = $ENV{$var_name_env};
            print $var_name_env . ":" . $ENV{$var_name_env} . "\n";
        }
    }
    # ---------- Default Environments ----------

    my $COMAINU_TEMP_DEFAULT = $DEFAULT_VALUES->{"comainu-temp"};

    print "\n";

    my $opts = {
        %$DEFAULT_VALUES,
        %$env_values,
    };
    GetOptions(
        $opts, "help", "debug=i", "version",
        "help-method", "list-method", "force",
        "comainu-home=s", "perl=s", "java=s",
        "yamcha-dir=s", "chasen-dir=s", "mecab-dir=s",
        "unidic-dir=s", "unidic2-dir=s", "unidic-db=s",
        "svm-tool-dir=s", "crf-dir=s",
        "mstparser-dir=s",
        "comainu-svm-bip-model=s",
        "comainu-output=s", "comainu-temp=s",
        "boundary=s",
        "luwmrph=s", "suwmodel=s", "luwmodel=s",
    );

    if ( $Config{"osname"} =~ /MSWin32|cygwin|msys/i ) {
        require ComainuGetPath;
        my $cgp = ComainuGetPath->new();
        foreach my $var_name ( @$OPT_NAME_LIST ) {
            my $value = $opts->{$var_name};
            $value = $cgp->adjust_winpath($value);
            $opts->{$var_name} = $value;
        }
    }

    foreach my $var_name ( @$OPT_NAME_LIST ) {
        my $var_name_env = uc $var_name;
        $var_name_env =~ s/\-/_/gs;
        $ENV{$var_name_env} = $opts->{$var_name};
    }

    if ( defined $opts->{help} ) {
        comainu_usage($opts);
        exit 0;
    }

    if ( defined $opts->{version} ) {
        comainu_version($opts);
        exit 0;
    }

    if ( defined $opts->{"help-method"} ) {
        my $flag = 0;
        foreach my $method_name ( @{method_names()} ) {
            my $usage_name = "USAGE_".$method_name;
            if (!$ARGV[0] || $method_name eq $ARGV[0]) {
                Comainu->$usage_name();
                ++$flag;
            }
        }
        if ($ARGV[0] && $flag == 0) {
            printf(STDERR "# Error: Not found the method: '%s'\n", $ARGV[0]);
        }
        exit 0;
    }

    if ( defined $opts->{"list-method"} ) {
        print "--- list of methods ---\n";
        foreach my $method_name ( @{method_names()} ) {
            printf("  %s\n", $method_name);
        }
        exit 0;
    }

    if (!defined $opts->{force} && !check_sub_tool_path($ARGV[0], $opts)) {
        exit 4;
    }

    $ENV{"DBG"} = "ON";

    my $comainu_method = "METHOD_" . $ARGV[0];
    $opts->{method} = $ARGV[0];
    my $comainu = Comainu->new(%$opts);
    unless ( $comainu->can($comainu_method) ) {
        printf(STDERR "Not found method : %s\n", $ARGV[0]);
        printf(STDERR "Supported methods are:\n");
        foreach my $method_name ( @{method_names()} ) {
            printf("  %s\n", $method_name);
        }
        exit 3;
    }

    $ENV{PRCCHARCODE} = "utf8";

    if ( $ENV{COMAINU_TEMP} =~ /^tmp\// &&
             ! -d $ENV{COMAINU_HOME} . "/tmp") {
        mkdir $ENV{COMAINU_HOME} . "/tmp";
    }
    mkdir $ENV{COMAINU_TEMP} unless -d $ENV{COMAINU_TEMP};
    unlink $ENV{COMAINU_TEMP} . "/*";

    $ENV{TEMP_FILELIST} = $ENV{COMAINU_TEMP} . "/filelist";
    unlink $ENV{TEMP_FILELIST} unless -d $ENV{TEMP_FILELIST};

    if ( $opts->{debug} ) {
        printf(STDERR "# method: %s->%s(%s)\n", $comainu, $comainu_method,
               join(", ", map {
                   my $x = "\"".$_."\"";
                   $x =~ s/\\/\\\\/gs;
                   $x;
               } @ARGV[1..$#ARGV]));
    }
    my $ret_code = $comainu->$comainu_method(@ARGV[1..$#ARGV]);

    print "\n";
    if ( $ret_code == 0 ) {
        print "Finish.\n";
    }
}

sub method_names {
    my $method_names = [];
    foreach my $method_name (sort keys %Comainu::) {
        if ($method_name =~ /^METHOD_/) {
            $method_name =~ s/^METHOD_//;
            push @$method_names, $method_name;
        }
    }
    return $method_names;
}

sub check_sub_tool_path {
    my ($method, $opts) = @_;

    if ( $method =~ /longmodel|bnstmodel/ ) {
        return 0 unless _check_tool_path($opts->{"yamcha-dir"}, 'yamcha');
        return 0 unless _check_tool_path($opts->{"svm-tool-dir"}, 'svm_learn');

        # check yamcha tool dir
        my $yamcha_tool_dir = $opts->{"yamcha-dir"} . "/libexec/yamcha";
        $yamcha_tool_dir = $opts->{"yamcha-dir"} . "/../libexec/yamcha"
            unless -d $yamcha_tool_dir;
        unless ( -d $yamcha_tool_dir ) {
            printf(STDERR "# Error: Not found YAMCHA TOOL_DIR (libexec/yamcha): '%s'\n",
                   $yamcha_tool_dir);
            return 0;
        }

        if ( $opts->{luwmodel} eq 'CRF' ) {
            return 0 unless _check_tool_path($opts->{'crf-dir'}, 'crf_learn');
        }
    }

    if ( $method =~ /midmodel|midout|midbnstout/ ) {
        unless ( -d $opts->{"mstparser-dir"} ) {
            printf(STDERR "# Error: Not found mstparser: '%s'\n",
                   $opts->{"mstparser-dir"});
            printf(STDERR "#   You might set wrong path or it was installed.\n");
            return 0;
        }
    }

    if ( $method =~ /longout|bnstout|longbnstout|midbnstout/ ) {
        return 0 unless _check_tool_path($opts->{"yamcha-dir"}, 'yamcha');
        return 0 unless _check_tool_path($opts->{"svm-tool-dir"}, 'svm_classify');
        if ( $opts->{luwmodel} eq 'CRF' ) {
            return 0 unless _check_tool_path($opts->{'crf-dir'}, 'crf_test');
        }
    }

    if ( $method =~ /plain2/ ) {
        if ( $opts->{suwmodel} eq 'chasen' ) {
            return 0 unless _check_tool_path($opts->{'chasen-dir'}, 'chasen');
        } elsif ( $opts->{suwmodel} eq 'mecab' ) {
            return 0 unless _check_tool_path($opts->{'mecab-dir'}, 'mecab');
        }
        return 0 unless _check_tool_dir($opts->{'unidic-dir'}, 'Unidic');
        return 0 unless _check_tool_dir($opts->{'unidic2-dir'}, 'Unidic2');
        unless ( -f $opts->{'unidic-db'} ) {
            printf(STDERR "# Error: Not found Unidic database: '%s'\n",
                   $opts->{"unidic-db"});
            printf(STDERR "#   You might set wrong path or it was installed.\n");
            return 0;
        }
    }

    return 1;
}

sub _check_tool_path {
    my ($tool_dir, $tool_cmd, $tool_name) = @_;

    unless ( -f $tool_dir . "/" . $tool_cmd ||
                 -f $tool_dir . "/" . $tool_cmd . "exe" ) {
        printf(STDERR "# Error: Not found %s: '%s'\n",
               $tool_name || $tool_cmd . ' command',
               $tool_dir . "/" . $tool_cmd);
        printf(STDERR "#   You might set wrong path or it was installed.\n");
        return 0;
    }
    return 1;
}

sub _check_tool_dir {
    my ($tool_dir, $tool_name) = @_;

    unless ( -d $tool_dir ) {
        printf(STDERR "# Error: Not found %s directory: '%s'\n",
               $tool_name, $tool_dir);
        printf(STDERR "#   You might set wrong path or it was installed.\n");
        return 0;
    }
    return 1;
}


comainu();

#################### end of file ####################
